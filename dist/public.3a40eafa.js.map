{"mappings":"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","sources":["<anon>","public/coordinateTest.js"],"sourcesContent":["// Browser-based coordinate parsing tests\n// Run this in the console to verify coordinate parsing\nfunction runCoordinateTests() {\n    console.log(\"\\uD83E\\uDDEA Running Coordinate Parsing Tests...\");\n    const tests = [\n        {\n            name: \"Basic key-value format\",\n            input: \"x:100 y:200 z:300\",\n            expected: {\n                x: 100,\n                y: 200,\n                z: 300,\n                distance: 1000,\n                direction: null\n            }\n        },\n        {\n            name: \"Key-value with distance and direction\",\n            input: \"x:0 y:1500 z:3500 d:3808 n:S.180\",\n            expected: {\n                x: 0,\n                y: 1500,\n                z: 3500,\n                distance: 3808,\n                direction: \"S.180\"\n            }\n        },\n        {\n            name: \"Negative coordinates\",\n            input: \"x:-115 y:-1546 z:3248 d:3 n:sw.215\",\n            expected: {\n                x: -115,\n                y: -1546,\n                z: 3248,\n                distance: 3,\n                direction: \"sw.215\"\n            }\n        },\n        {\n            name: \"Problem case 1: -734.700.1370.10.ne.80\",\n            input: \"-734.700.1370.10.ne.80\",\n            expected: {\n                x: -734,\n                y: 700,\n                z: 1370,\n                distance: 10,\n                direction: \"ne.80\"\n            }\n        },\n        {\n            name: \"Problem case 2: -1160.729.1189.961.SE.121\",\n            input: \"-1160.729.1189.961.SE.121\",\n            expected: {\n                x: -1160,\n                y: 729,\n                z: 1189,\n                distance: 961,\n                direction: \"SE.121\"\n            }\n        },\n        {\n            name: \"Problem case 3: 0.1500.3500.3808.S.120\",\n            input: \"0.1500.3500.3808.S.120\",\n            expected: {\n                x: 0,\n                y: 1500,\n                z: 3500,\n                distance: 3808,\n                direction: \"S.120\"\n            }\n        }\n    ];\n    let passed = 0;\n    let failed = 0;\n    for (const test of tests){\n        console.log(`\n\\u{1F9EA} Testing: ${test.name}`);\n        console.log(`   Input: \"${test.input}\"`);\n        try {\n            const result = parseCoordinateInput(test.input);\n            console.log(`   Result:`, result);\n            console.log(`   Expected:`, test.expected);\n            // Check if results match\n            const matches = result.x === test.expected.x && result.y === test.expected.y && result.z === test.expected.z && result.distance === test.expected.distance && result.direction === test.expected.direction;\n            if (matches) {\n                console.log(`   \\u{2705} PASSED`);\n                passed++;\n            } else {\n                console.error(`   \\u{274C} FAILED`);\n                console.error(`   Differences:`, {\n                    x: result.x !== test.expected.x ? `got ${result.x}, expected ${test.expected.x}` : 'OK',\n                    y: result.y !== test.expected.y ? `got ${result.y}, expected ${test.expected.y}` : 'OK',\n                    z: result.z !== test.expected.z ? `got ${result.z}, expected ${test.expected.z}` : 'OK',\n                    distance: result.distance !== test.expected.distance ? `got ${result.distance}, expected ${test.expected.distance}` : 'OK',\n                    direction: result.direction !== test.expected.direction ? `got ${result.direction}, expected ${test.expected.direction}` : 'OK'\n                });\n                failed++;\n            }\n        } catch (error) {\n            console.error(`   \\u{274C} ERROR:`, error);\n            failed++;\n        }\n    }\n    console.log(`\n\\u{1F9EA} Test Results: ${passed} passed, ${failed} failed`);\n    if (failed === 0) console.log(\"\\uD83C\\uDF89 All tests passed!\");\n    else console.error(\"\\u274C Some tests failed. Check the parsing logic.\");\n    return {\n        passed,\n        failed\n    };\n}\n// Test navigation by comparing actual camera position after goToPosition\nfunction testNavigation() {\n    console.log(\"\\uD83D\\uDE80 Testing Navigation System...\");\n    const testCases = [\n        {\n            name: \"Simple test case\",\n            input: \"0.100.200.50\",\n            expected: {\n                x: 0,\n                y: 100,\n                z: 200,\n                distance: 50\n            }\n        },\n        {\n            name: \"Problem case 1\",\n            input: \"-734.700.1370.10.ne.80\",\n            expected: {\n                x: -734,\n                y: 700,\n                z: 1370,\n                distance: 10\n            }\n        }\n    ];\n    for (const test of testCases){\n        console.log(`\n\\u{1F680} Testing navigation: ${test.name}`);\n        console.log(`   Input: \"${test.input}\"`);\n        // Parse coordinates\n        const parsed = parseCoordinateInput(test.input);\n        console.log(`   Parsed:`, parsed);\n        console.log(`   Expected:`, test.expected);\n        // Store current camera state\n        const beforeCamera = {\n            position: {\n                x: camera.position.x,\n                y: camera.position.y,\n                z: camera.position.z\n            },\n            target: {\n                x: controls.target.x,\n                y: controls.target.y,\n                z: controls.target.z\n            }\n        };\n        console.log(`   Before navigation - Camera:`, beforeCamera);\n        // Navigate\n        console.log(`   Calling goToPosition(${parsed.x}, ${parsed.y}, ${parsed.z}, ${parsed.distance}, \"${parsed.direction}\")...`);\n        goToPosition(parsed.x, parsed.y, parsed.z, parsed.distance, parsed.direction);\n        // Check camera state after navigation (need to wait a bit for animation)\n        setTimeout(()=>{\n            const afterCamera = {\n                position: {\n                    x: Math.round(camera.position.x),\n                    y: Math.round(camera.position.y),\n                    z: Math.round(camera.position.z)\n                },\n                target: {\n                    x: Math.round(controls.target.x),\n                    y: Math.round(controls.target.y),\n                    z: Math.round(controls.target.z)\n                }\n            };\n            console.log(`   After navigation - Camera:`, afterCamera);\n            // The target should match the parsed coordinates\n            const targetMatches = Math.abs(afterCamera.target.x - parsed.x) < 1 && Math.abs(afterCamera.target.y - parsed.y) < 1 && Math.abs(afterCamera.target.z - parsed.z) < 1;\n            if (targetMatches) console.log(`   \\u{2705} Target matches parsed coordinates`);\n            else {\n                console.error(`   \\u{274C} Target doesn't match!`);\n                console.error(`   Expected target: x:${parsed.x}, y:${parsed.y}, z:${parsed.z}`);\n                console.error(`   Actual target: x:${afterCamera.target.x}, y:${afterCamera.target.y}, z:${afterCamera.target.z}`);\n            }\n        }, 2000); // Wait 2 seconds for animation to complete\n    }\n}\n// Test the navigation lock mechanism\nfunction testNavigationLock() {\n    console.log(\"\\uD83D\\uDD12 Testing Navigation Lock System...\");\n    // Test rapid sequential calls to goToPosition\n    const testCases = [\n        {\n            name: \"First call\",\n            input: \"100.200.300.50\",\n            expected: {\n                x: 100,\n                y: 200,\n                z: 300\n            }\n        },\n        {\n            name: \"Second call (should cancel first)\",\n            input: \"0.500.1000.75\",\n            expected: {\n                x: 0,\n                y: 500,\n                z: 1000\n            }\n        },\n        {\n            name: \"Third call (should cancel second)\",\n            input: \"-200.800.600.100\",\n            expected: {\n                x: -200,\n                y: 800,\n                z: 600\n            }\n        }\n    ];\n    console.log(\"\\uD83D\\uDE80 Making rapid sequential navigation calls...\");\n    // Store initial state\n    const initialCamera = {\n        position: {\n            x: camera.position.x,\n            y: camera.position.y,\n            z: camera.position.z\n        },\n        target: {\n            x: controls.target.x,\n            y: controls.target.y,\n            z: controls.target.z\n        }\n    };\n    console.log(\"\\uD83D\\uDCCD Initial state:\", initialCamera);\n    // Make three rapid calls (should test the lock mechanism)\n    testCases.forEach((test, index)=>{\n        const parsed = parseCoordinateInput(test.input);\n        console.log(`\\u{1F680} Call ${index + 1} - ${test.name}: goToPosition(${parsed.x}, ${parsed.y}, ${parsed.z}, ${parsed.distance || 50})`);\n        console.log(`   Navigation lock before call: ${navigationLock()}`);\n        goToPosition(parsed.x, parsed.y, parsed.z, parsed.distance || 50, parsed.direction);\n        console.log(`   Navigation lock after call: ${navigationLock()}`);\n        console.log(`   Animation ID after call: ${currentAnimationId() ? 'Active' : 'None'}`);\n    });\n    console.log(\"\\u23F3 Waiting 3 seconds for final animation to complete...\");\n    // Check final state after animations complete\n    setTimeout(()=>{\n        const finalCamera = {\n            position: {\n                x: Math.round(camera.position.x),\n                y: Math.round(camera.position.y),\n                z: Math.round(camera.position.z)\n            },\n            target: {\n                x: Math.round(controls.target.x),\n                y: Math.round(controls.target.y),\n                z: Math.round(controls.target.z)\n            }\n        };\n        console.log(\"\\uD83D\\uDCCD Final state:\", finalCamera);\n        console.log(`\\u{1F512} Final navigation lock: ${navigationLock()}`);\n        console.log(`\\u{1F3AC} Final animation ID: ${currentAnimationId() ? 'Active' : 'None'}`);\n        // The final position should match the last (third) call\n        const expectedFinal = testCases[2];\n        const parsedFinal = parseCoordinateInput(expectedFinal.input);\n        const targetMatches = Math.abs(finalCamera.target.x - parsedFinal.x) < 5 && Math.abs(finalCamera.target.y - parsedFinal.y) < 5 && Math.abs(finalCamera.target.z - parsedFinal.z) < 5;\n        if (targetMatches) console.log(\"\\u2705 Navigation lock test PASSED - Final position matches last call\");\n        else {\n            console.error(\"\\u274C Navigation lock test FAILED - Final position does not match last call\");\n            console.error(`   Expected: x:${parsedFinal.x}, y:${parsedFinal.y}, z:${parsedFinal.z}`);\n            console.error(`   Actual: x:${finalCamera.target.x}, y:${finalCamera.target.y}, z:${finalCamera.target.z}`);\n        }\n        // Check that navigation is unlocked\n        if (!navigationLock() && !currentAnimationId()) console.log(\"\\u2705 Navigation properly unlocked after completion\");\n        else console.error(\"\\u274C Navigation still locked or animation still running\");\n    }, 3000);\n}\n// Export for use in console\nwindow.runCoordinateTests = runCoordinateTests;\nwindow.testNavigation = testNavigation;\nwindow.testNavigationLock = testNavigationLock;\n\n//# sourceMappingURL=public.3a40eafa.js.map\n","// Browser-based coordinate parsing tests\n// Run this in the console to verify coordinate parsing\n\nfunction runCoordinateTests() {\n    console.log('🧪 Running Coordinate Parsing Tests...');\n    \n    const tests = [\n        {\n            name: \"Basic key-value format\",\n            input: \"x:100 y:200 z:300\",\n            expected: { x: 100, y: 200, z: 300, distance: 1000, direction: null }\n        },\n        {\n            name: \"Key-value with distance and direction\",\n            input: \"x:0 y:1500 z:3500 d:3808 n:S.180\",\n            expected: { x: 0, y: 1500, z: 3500, distance: 3808, direction: \"S.180\" }\n        },\n        {\n            name: \"Negative coordinates\",\n            input: \"x:-115 y:-1546 z:3248 d:3 n:sw.215\",\n            expected: { x: -115, y: -1546, z: 3248, distance: 3, direction: \"sw.215\" }\n        },\n        {\n            name: \"Problem case 1: -734.700.1370.10.ne.80\",\n            input: \"-734.700.1370.10.ne.80\",\n            expected: { x: -734, y: 700, z: 1370, distance: 10, direction: \"ne.80\" }\n        },\n        {\n            name: \"Problem case 2: -1160.729.1189.961.SE.121\",\n            input: \"-1160.729.1189.961.SE.121\",\n            expected: { x: -1160, y: 729, z: 1189, distance: 961, direction: \"SE.121\" }\n        },\n        {\n            name: \"Problem case 3: 0.1500.3500.3808.S.120\",\n            input: \"0.1500.3500.3808.S.120\",\n            expected: { x: 0, y: 1500, z: 3500, distance: 3808, direction: \"S.120\" }\n        }\n    ];\n    \n    let passed = 0;\n    let failed = 0;\n    \n    for (const test of tests) {\n        console.log(`\\n🧪 Testing: ${test.name}`);\n        console.log(`   Input: \"${test.input}\"`);\n        \n        try {\n            const result = parseCoordinateInput(test.input);\n            console.log(`   Result:`, result);\n            console.log(`   Expected:`, test.expected);\n            \n            // Check if results match\n            const matches = (\n                result.x === test.expected.x &&\n                result.y === test.expected.y &&\n                result.z === test.expected.z &&\n                result.distance === test.expected.distance &&\n                result.direction === test.expected.direction\n            );\n            \n            if (matches) {\n                console.log(`   ✅ PASSED`);\n                passed++;\n            } else {\n                console.error(`   ❌ FAILED`);\n                console.error(`   Differences:`, {\n                    x: result.x !== test.expected.x ? `got ${result.x}, expected ${test.expected.x}` : 'OK',\n                    y: result.y !== test.expected.y ? `got ${result.y}, expected ${test.expected.y}` : 'OK',\n                    z: result.z !== test.expected.z ? `got ${result.z}, expected ${test.expected.z}` : 'OK',\n                    distance: result.distance !== test.expected.distance ? `got ${result.distance}, expected ${test.expected.distance}` : 'OK',\n                    direction: result.direction !== test.expected.direction ? `got ${result.direction}, expected ${test.expected.direction}` : 'OK'\n                });\n                failed++;\n            }\n        } catch (error) {\n            console.error(`   ❌ ERROR:`, error);\n            failed++;\n        }\n    }\n    \n    console.log(`\\n🧪 Test Results: ${passed} passed, ${failed} failed`);\n    \n    if (failed === 0) {\n        console.log('🎉 All tests passed!');\n    } else {\n        console.error('❌ Some tests failed. Check the parsing logic.');\n    }\n    \n    return { passed, failed };\n}\n\n// Test navigation by comparing actual camera position after goToPosition\nfunction testNavigation() {\n    console.log('🚀 Testing Navigation System...');\n    \n    const testCases = [\n        {\n            name: \"Simple test case\",\n            input: \"0.100.200.50\",\n            expected: { x: 0, y: 100, z: 200, distance: 50 }\n        },\n        {\n            name: \"Problem case 1\",\n            input: \"-734.700.1370.10.ne.80\",\n            expected: { x: -734, y: 700, z: 1370, distance: 10 }\n        }\n    ];\n    \n    for (const test of testCases) {\n        console.log(`\\n🚀 Testing navigation: ${test.name}`);\n        console.log(`   Input: \"${test.input}\"`);\n        \n        // Parse coordinates\n        const parsed = parseCoordinateInput(test.input);\n        console.log(`   Parsed:`, parsed);\n        console.log(`   Expected:`, test.expected);\n        \n        // Store current camera state\n        const beforeCamera = {\n            position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },\n            target: { x: controls.target.x, y: controls.target.y, z: controls.target.z }\n        };\n        console.log(`   Before navigation - Camera:`, beforeCamera);\n        \n        // Navigate\n        console.log(`   Calling goToPosition(${parsed.x}, ${parsed.y}, ${parsed.z}, ${parsed.distance}, \"${parsed.direction}\")...`);\n        goToPosition(parsed.x, parsed.y, parsed.z, parsed.distance, parsed.direction);\n        \n        // Check camera state after navigation (need to wait a bit for animation)\n        setTimeout(() => {\n            const afterCamera = {\n                position: { x: Math.round(camera.position.x), y: Math.round(camera.position.y), z: Math.round(camera.position.z) },\n                target: { x: Math.round(controls.target.x), y: Math.round(controls.target.y), z: Math.round(controls.target.z) }\n            };\n            console.log(`   After navigation - Camera:`, afterCamera);\n            \n            // The target should match the parsed coordinates\n            const targetMatches = (\n                Math.abs(afterCamera.target.x - parsed.x) < 1 &&\n                Math.abs(afterCamera.target.y - parsed.y) < 1 &&\n                Math.abs(afterCamera.target.z - parsed.z) < 1\n            );\n            \n            if (targetMatches) {\n                console.log(`   ✅ Target matches parsed coordinates`);\n            } else {\n                console.error(`   ❌ Target doesn't match!`);\n                console.error(`   Expected target: x:${parsed.x}, y:${parsed.y}, z:${parsed.z}`);\n                console.error(`   Actual target: x:${afterCamera.target.x}, y:${afterCamera.target.y}, z:${afterCamera.target.z}`);\n            }\n        }, 2000); // Wait 2 seconds for animation to complete\n    }\n}\n\n// Test the navigation lock mechanism\nfunction testNavigationLock() {\n    console.log('🔒 Testing Navigation Lock System...');\n    \n    // Test rapid sequential calls to goToPosition\n    const testCases = [\n        { name: \"First call\", input: \"100.200.300.50\", expected: { x: 100, y: 200, z: 300 } },\n        { name: \"Second call (should cancel first)\", input: \"0.500.1000.75\", expected: { x: 0, y: 500, z: 1000 } },\n        { name: \"Third call (should cancel second)\", input: \"-200.800.600.100\", expected: { x: -200, y: 800, z: 600 } }\n    ];\n    \n    console.log('🚀 Making rapid sequential navigation calls...');\n    \n    // Store initial state\n    const initialCamera = {\n        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },\n        target: { x: controls.target.x, y: controls.target.y, z: controls.target.z }\n    };\n    console.log('📍 Initial state:', initialCamera);\n    \n    // Make three rapid calls (should test the lock mechanism)\n    testCases.forEach((test, index) => {\n        const parsed = parseCoordinateInput(test.input);\n        console.log(`🚀 Call ${index + 1} - ${test.name}: goToPosition(${parsed.x}, ${parsed.y}, ${parsed.z}, ${parsed.distance || 50})`);\n        console.log(`   Navigation lock before call: ${navigationLock()}`);\n        \n        goToPosition(parsed.x, parsed.y, parsed.z, parsed.distance || 50, parsed.direction);\n        \n        console.log(`   Navigation lock after call: ${navigationLock()}`);\n        console.log(`   Animation ID after call: ${currentAnimationId() ? 'Active' : 'None'}`);\n    });\n    \n    console.log('⏳ Waiting 3 seconds for final animation to complete...');\n    \n    // Check final state after animations complete\n    setTimeout(() => {\n        const finalCamera = {\n            position: { x: Math.round(camera.position.x), y: Math.round(camera.position.y), z: Math.round(camera.position.z) },\n            target: { x: Math.round(controls.target.x), y: Math.round(controls.target.y), z: Math.round(controls.target.z) }\n        };\n        \n        console.log('📍 Final state:', finalCamera);\n        console.log(`🔒 Final navigation lock: ${navigationLock()}`);\n        console.log(`🎬 Final animation ID: ${currentAnimationId() ? 'Active' : 'None'}`);\n        \n        // The final position should match the last (third) call\n        const expectedFinal = testCases[2];\n        const parsedFinal = parseCoordinateInput(expectedFinal.input);\n        \n        const targetMatches = (\n            Math.abs(finalCamera.target.x - parsedFinal.x) < 5 &&\n            Math.abs(finalCamera.target.y - parsedFinal.y) < 5 &&\n            Math.abs(finalCamera.target.z - parsedFinal.z) < 5\n        );\n        \n        if (targetMatches) {\n            console.log('✅ Navigation lock test PASSED - Final position matches last call');\n        } else {\n            console.error('❌ Navigation lock test FAILED - Final position does not match last call');\n            console.error(`   Expected: x:${parsedFinal.x}, y:${parsedFinal.y}, z:${parsedFinal.z}`);\n            console.error(`   Actual: x:${finalCamera.target.x}, y:${finalCamera.target.y}, z:${finalCamera.target.z}`);\n        }\n        \n        // Check that navigation is unlocked\n        if (!navigationLock() && !currentAnimationId()) {\n            console.log('✅ Navigation properly unlocked after completion');\n        } else {\n            console.error('❌ Navigation still locked or animation still running');\n        }\n        \n    }, 3000);\n}\n\n// Export for use in console\nwindow.runCoordinateTests = runCoordinateTests;\nwindow.testNavigation = testNavigation;\nwindow.testNavigationLock = testNavigationLock;"],"names":["runCoordinateTests","console","log","passed","failed","test","name","input","expected","x","y","z","distance","direction","result","parseCoordinateInput","error","testNavigation","parsed","position","camera","target","controls","goToPosition","setTimeout","afterCamera","Math","round","abs","testNavigationLock","testCases","forEach","index","navigationLock","currentAnimationId","finalCamera","parsedFinal","expectedFinal","window"],"version":3,"file":"public.3a40eafa.js.map"}